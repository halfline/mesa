diff --git a/Makefile.am b/Makefile.am
index 9a0c1dd..3caa121 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -61,6 +61,7 @@ PACKAGE_NAME = MesaLib-$(PACKAGE_VERSION)
 EXTRA_FILES = \
 	aclocal.m4					\
 	configure					\
+	bin/install-sh					\
 	src/glsl/glsl_parser.cc				\
 	src/glsl/glsl_parser.h				\
 	src/glsl/glsl_lexer.cc				\
diff --git a/bin/get-pick-list.sh b/bin/get-pick-list.sh
new file mode 100755
index 0000000..7288090
--- /dev/null
+++ b/bin/get-pick-list.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+# Script for generating a list of candidates for cherry-picking to a stable branch
+
+# Grep for commits with "cherry picked from commit" in the commit message.
+git log --reverse --grep="cherry picked from commit" origin/master..HEAD |\
+	grep "cherry picked from commit" |\
+	sed -e 's/^[[:space:]]*(cherry picked from commit[[:space:]]*//' -e 's/)//' > already_picked
+
+# Grep for commits that were marked as a candidate for the stable tree.
+git log --reverse --pretty=%H -i --grep='^[[:space:]]*NOTE: This is a candidate' HEAD..origin/master |\
+while read sha
+do
+	# Check to see whether the patch is on the ignore list.
+	if [ -f .git/cherry-ignore ] ; then
+		if grep -q ^$sha .git/cherry-ignore ; then
+			continue
+		fi
+	fi
+
+	# Check to see if it has already been picked over.
+	if grep -q ^$sha already_picked ; then
+		continue
+	fi
+
+	git log -n1 --pretty=oneline $sha | cat
+done
+
+rm -f already_picked
diff --git a/configure.ac b/configure.ac
index 2d922f6..e7a7241 100644
--- a/configure.ac
+++ b/configure.ac
@@ -160,13 +160,13 @@ DEFINES=""
 AC_SUBST([DEFINES])
 case "$host_os" in
 linux*|*-gnu*|gnu*)
-    DEFINES="$DEFINES -D_GNU_SOURCE"
+    DEFINES="$DEFINES -D_GNU_SOURCE -DHAVE_PTHREAD"
     ;;
 solaris*)
-    DEFINES="$DEFINES -DSVR4"
+    DEFINES="$DEFINES -DHAVE_PTHREAD -DSVR4"
     ;;
 cygwin*)
-    DEFINES="$DEFINES"
+    DEFINES="$DEFINES -DHAVE_PTHREAD"
     ;;
 esac
 
@@ -946,7 +946,7 @@ AC_ARG_ENABLE([glx-tls],
 AC_SUBST(GLX_TLS, ${GLX_USE_TLS})
 
 AS_IF([test "x$GLX_USE_TLS" = xyes -a "x$ax_pthread_ok" = xyes],
-      [DEFINES="${DEFINES} -DGLX_USE_TLS"])
+      [DEFINES="${DEFINES} -DGLX_USE_TLS -DHAVE_PTHREAD"])
 
 dnl
 dnl More DRI setup
@@ -1030,7 +1030,7 @@ if test "x$enable_dri" = xyes; then
         esac
         ;;
     freebsd* | dragonfly* | *netbsd*)
-        DEFINES="$DEFINES -DUSE_EXTERNAL_DXTN_LIB=1"
+        DEFINES="$DEFINES -DHAVE_PTHREAD -DUSE_EXTERNAL_DXTN_LIB=1"
         DEFINES="$DEFINES -DIN_DRI_DRIVER -DHAVE_ALIAS"
 
         if test "x$DRI_DIRS" = "xyes"; then
@@ -1222,8 +1222,6 @@ if test "x$enable_gbm" = xyes; then
         if test "x$enable_shared_glapi" = xno; then
             AC_MSG_ERROR([gbm_dri requires --enable-shared-glapi])
         fi
-        PKG_CHECK_MODULES([LIBKMS], [libkms], [],
-                          AC_MSG_ERROR([gbm needs libkms]))
     fi
 fi
 GBM_PC_REQ_PRIV="libudev"
@@ -1518,7 +1516,7 @@ for plat in $egl_platforms; do
 		;;
 
 	wayland)
-		PKG_CHECK_MODULES([WAYLAND], [wayland-client wayland-server],, \
+		PKG_CHECK_MODULES([WAYLAND], [wayland-client >= 0.99.0 wayland-server >= 0.99.0],, \
 				  [AC_MSG_ERROR([cannot find libwayland-client])])
 		GALLIUM_WINSYS_DIRS="$GALLIUM_WINSYS_DIRS sw/wayland"
 
diff --git a/docs/news.html b/docs/news.html
index 541bde6..26e648b 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -9,6 +9,16 @@
 
 <h1>News</h1>
 
+<h2>October 8, 2012</h2>
+
+<p>
+<a href="relnotes-9.0.html">Mesa 9.0</a> is released.
+This is the first version of Mesa to support OpenGL 3.1 and GLSL 1.40
+(with the i965 driver).
+See the release notes for more information about the release.
+</p>
+
+
 <h2>July 10, 2012</h2>
 
 <p>
diff --git a/docs/relnotes-9.0.html b/docs/relnotes-9.0.html
index d72c5bb..02b7324 100644
--- a/docs/relnotes-9.0.html
+++ b/docs/relnotes-9.0.html
@@ -26,7 +26,9 @@ because GL_ARB_compatibility is not supported.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+be4cd34c6599a7cb9d254b05c48bdb1f  MesaLib-9.0.tar.gz
+60e557ce407be3732711da484ab3db6c  MesaLib-9.0.tar.bz2
+16b128544cd3f7e237927bb9f8aab7ce  MesaLib-9.0.zip
 </pre>
 
 
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 81c1354..3c42338 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -122,8 +122,10 @@ struct dri2_egl_display
 
 #ifdef HAVE_WAYLAND_PLATFORM
    struct wl_display        *wl_dpy;
+   struct wl_registry       *wl_registry;
    struct wl_drm            *wl_server_drm;
    struct wl_drm            *wl_drm;
+   struct wl_event_queue    *wl_queue;
    int			     authenticated;
    int			     formats;
 #endif
@@ -174,7 +176,7 @@ struct dri2_egl_surface
    __DRIbuffer           *dri_buffers[__DRI_BUFFER_COUNT];
    __DRIbuffer           *third_buffer;
    __DRIbuffer           *pending_buffer;
-   EGLBoolean             block_swap_buffers;
+   struct wl_callback    *frame_callback;
    int			  format;
 #endif
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index d291f0f..dcf3601 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -46,6 +46,34 @@ enum wl_drm_format_flags {
 };
 
 static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+   int *done = data;
+
+   *done = 1;
+   wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+static int
+roundtrip(struct dri2_egl_display *dri2_dpy)
+{
+   struct wl_callback *callback;
+   int done = 0, ret = 0;
+
+   callback = wl_display_sync(dri2_dpy->wl_dpy);
+   wl_callback_add_listener(callback, &sync_listener, &done);
+   wl_proxy_set_queue((struct wl_proxy *) callback, dri2_dpy->wl_queue);
+   while (ret != -1 && !done)
+      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
+
+   return ret;
+}
+
+static void
 wl_buffer_release(void *data, struct wl_buffer *buffer)
 {
    struct dri2_egl_surface *dri2_surf = data;
@@ -80,7 +108,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
    struct dri2_egl_surface *dri2_surf;
-   struct dri2_egl_buffer *dri2_buf;
    int i;
 
    (void) drv;
@@ -104,7 +131,7 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
 
    dri2_surf->pending_buffer = NULL;
    dri2_surf->third_buffer = NULL;
-   dri2_surf->block_swap_buffers = EGL_FALSE;
+   dri2_surf->frame_callback = NULL;
 
    if (conf->AlphaSize == 0)
       dri2_surf->format = WL_DRM_FORMAT_XRGB8888;
@@ -118,17 +145,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       dri2_surf->base.Width =  -1;
       dri2_surf->base.Height = -1;
       break;
-   case EGL_PIXMAP_BIT:
-      dri2_surf->wl_pix = (struct wl_egl_pixmap *) window;
-
-      dri2_surf->base.Width  = dri2_surf->wl_pix->width;
-      dri2_surf->base.Height = dri2_surf->wl_pix->height;
-
-      if (dri2_surf->wl_pix->driver_private) {
-         dri2_buf = dri2_surf->wl_pix->driver_private;
-         dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] = dri2_buf->dri_buffer;
-      }
-      break;
    default: 
       goto cleanup_surf;
    }
@@ -166,15 +182,6 @@ dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
 			      window, attrib_list);
 }
 
-static _EGLSurface *
-dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
-			   _EGLConfig *conf, EGLNativePixmapType pixmap,
-			   const EGLint *attrib_list)
-{
-   return dri2_create_surface(drv, disp, EGL_PIXMAP_BIT, conf,
-			      pixmap, attrib_list);
-}
-
 /**
  * Called via eglDestroySurface(), drv->API.DestroySurface().
  */
@@ -197,8 +204,7 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
          wl_buffer_destroy(dri2_surf->wl_drm_buffer[i]);
 
    for (i = 0; i < __DRI_BUFFER_COUNT; ++i)
-      if (dri2_surf->dri_buffers[i] && !(i == __DRI_BUFFER_FRONT_LEFT &&
-          dri2_surf->base.Type == EGL_PIXMAP_BIT))
+      if (dri2_surf->dri_buffers[i])
          dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                        dri2_surf->dri_buffers[i]);
 
@@ -212,22 +218,6 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
    return EGL_TRUE;
 }
 
-static void
-dri2_wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct dri2_egl_buffer *dri2_buf = egl_pixmap->driver_private;
-
-   assert(dri2_buf);
-
-   dri2_buf->dri2_dpy->dri2->releaseBuffer(dri2_buf->dri2_dpy->dri_screen,
-                                           dri2_buf->dri_buffer);
-
-   free(dri2_buf);
-   
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
 static struct wl_buffer *
 wayland_create_buffer(struct dri2_egl_surface *dri2_surf,
                       __DRIbuffer *buffer)
@@ -268,30 +258,6 @@ dri2_process_back_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
 }
 
 static void
-dri2_process_front_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
-{
-   struct dri2_egl_display *dri2_dpy =
-      dri2_egl_display(dri2_surf->base.Resource.Display);
-   struct dri2_egl_buffer *dri2_buf;
-
-   switch (dri2_surf->base.Type) {
-   case EGL_PIXMAP_BIT:
-      dri2_buf = malloc(sizeof *dri2_buf);
-      if (!dri2_buf)
-         return;
-
-      dri2_buf->dri_buffer = dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT];
-      dri2_buf->dri2_dpy   = dri2_dpy;
-
-      dri2_surf->wl_pix->driver_private = dri2_buf;
-      dri2_surf->wl_pix->destroy        = dri2_wl_egl_pixmap_destroy;
-      break;
-   default:
-      break;
-   }
-}
-
-static void
 dri2_release_pending_buffer(void *data,
 			    struct wl_callback *callback, uint32_t time)
 {
@@ -333,11 +299,13 @@ dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
          switch (i) {
          case __DRI_BUFFER_FRONT_LEFT:
             if (dri2_surf->pending_buffer)
-	      wl_display_roundtrip(dri2_dpy->wl_dpy);
+               roundtrip(dri2_dpy);
             dri2_surf->pending_buffer = dri2_surf->dri_buffers[i];
             callback = wl_display_sync(dri2_dpy->wl_dpy);
 	    wl_callback_add_listener(callback,
 				     &release_buffer_listener, dri2_surf);
+            wl_proxy_set_queue((struct wl_proxy *) callback,
+                               dri2_dpy->wl_queue);
             break;
          default:
             dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
@@ -466,9 +434,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
          if (!dri2_surf->dri_buffers[attachments[i]]) 
             continue;
 
-         if (attachments[i] == __DRI_BUFFER_FRONT_LEFT)
-            dri2_process_front_buffer(dri2_surf, attachments[i+1]);
-         else if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
+         if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
             dri2_process_back_buffer(dri2_surf, attachments[i+1]);
       }
 
@@ -479,13 +445,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
       dri2_surf->buffer_count++;
    }
 
-   assert(dri2_surf->base.Type == EGL_PIXMAP_BIT ||
-          dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
-
-   if (dri2_surf->base.Type == EGL_PIXMAP_BIT && !dri2_surf->wl_pix->buffer)
-      dri2_surf->wl_pix->buffer =
-         wayland_create_buffer(dri2_surf,
-			       dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT]);
+   assert(dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
 
    *out_count = dri2_surf->buffer_count;
    if (dri2_surf->buffer_count == 0)
@@ -552,7 +512,7 @@ wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
 {
    struct dri2_egl_surface *dri2_surf = data;
 
-   dri2_surf->block_swap_buffers = EGL_FALSE;
+   dri2_surf->frame_callback = NULL;
    wl_callback_destroy(callback);
 }
 
@@ -569,17 +529,18 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
    struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
-   struct wl_callback *callback;
+   int ret = 0;
 
-   if (dri2_surf->block_swap_buffers) {
-      wl_display_flush(dri2_dpy->wl_dpy);
-      while (dri2_surf->block_swap_buffers)
-         wl_display_iterate(dri2_dpy->wl_dpy, WL_DISPLAY_READABLE);
-   }
+   while (dri2_surf->frame_callback && ret != -1)
+      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
+   if (ret < 0)
+      return EGL_FALSE;
 
-   dri2_surf->block_swap_buffers = EGL_TRUE;
-   callback = wl_surface_frame(dri2_surf->wl_win->surface);
-   wl_callback_add_listener(callback, &frame_listener, dri2_surf);
+   dri2_surf->frame_callback = wl_surface_frame(dri2_surf->wl_win->surface);
+   wl_callback_add_listener(dri2_surf->frame_callback,
+                            &frame_listener, dri2_surf);
+   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->frame_callback,
+                      dri2_dpy->wl_queue);
 
    if (dri2_surf->base.Type == EGL_WINDOW_BIT) {
       pointer_swap(
@@ -611,6 +572,8 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
 
       wl_surface_damage(dri2_surf->wl_win->surface, 0, 0,
 	    dri2_surf->base.Width, dri2_surf->base.Height);
+
+      wl_surface_commit(dri2_surf->wl_win->surface);
    }
 
    _EGLContext *ctx;
@@ -626,71 +589,6 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
    return EGL_TRUE;
 }
 
-/**
- * Called via eglCreateImageKHR(), drv->API.CreateImageKHR().
- */
-static _EGLImage *
-dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
-			     EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct wl_egl_pixmap *wl_egl_pixmap = (struct wl_egl_pixmap *) buffer;
-   struct dri2_egl_buffer *dri2_buf;
-   EGLint wl_attr_list[] = {
-		EGL_WIDTH,		0,
-		EGL_HEIGHT,		0,
-		EGL_DRM_BUFFER_STRIDE_MESA,	0,
-		EGL_DRM_BUFFER_FORMAT_MESA,	EGL_DRM_BUFFER_FORMAT_ARGB32_MESA,
-		EGL_NONE
-   };
-
-   dri2_buf = malloc(sizeof *dri2_buf);
-   if (!dri2_buf)
-           return NULL;
-
-   dri2_buf->dri2_dpy = dri2_dpy;
-   dri2_buf->dri_buffer =
-      dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
-				     __DRI_BUFFER_FRONT_LEFT, 32,
-				     wl_egl_pixmap->width,
-				     wl_egl_pixmap->height);
-
-   wl_egl_pixmap->destroy = dri2_wl_egl_pixmap_destroy;
-   wl_egl_pixmap->driver_private = dri2_buf;
-
-   /* FIXME: Get buffer format from attr_list somehow... or from the
-      wl_egl_piaxmap.  */
-   wl_egl_pixmap->buffer =
-      wl_drm_create_buffer(dri2_dpy->wl_drm,
-			   dri2_buf->dri_buffer->name,
-			   wl_egl_pixmap->width,
-			   wl_egl_pixmap->height,
-			   dri2_buf->dri_buffer->pitch,
-			   WL_DRM_FORMAT_ARGB8888);
-
-   wl_attr_list[1] = wl_egl_pixmap->width;
-   wl_attr_list[3] = wl_egl_pixmap->height;
-   wl_attr_list[5] = dri2_buf->dri_buffer->pitch / 4;
-
-   return dri2_create_image_khr(disp->Driver, disp, ctx, EGL_DRM_BUFFER_MESA,
-	(EGLClientBuffer)(intptr_t) dri2_buf->dri_buffer->name, wl_attr_list);
-}
-
-static _EGLImage *
-dri2_wayland_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
-			      _EGLContext *ctx, EGLenum target,
-			      EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   (void) drv;
-
-   switch (target) {
-   case EGL_NATIVE_PIXMAP_KHR:
-      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
-   default:
-      return dri2_create_image_khr(drv, disp, ctx, target, buffer, attr_list);
-   }
-}
-
 static int
 dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
 {
@@ -700,7 +598,8 @@ dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
    dri2_dpy->authenticated = 0;
 
    wl_drm_authenticate(dri2_dpy->wl_drm, id);
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
+   if (roundtrip(dri2_dpy) < 0)
+      ret = -1;
 
    if (!dri2_dpy->authenticated)
       ret = -1;
@@ -795,22 +694,37 @@ static const struct wl_drm_listener drm_listener = {
 	drm_handle_authenticated
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+		       const char *interface, uint32_t version)
+{
+   struct dri2_egl_display *dri2_dpy = data;
+
+   if (strcmp(interface, "wl_drm") == 0) {
+      dri2_dpy->wl_drm =
+         wl_registry_bind(registry, name, &wl_drm_interface, 1);
+      wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global
+};
+
 EGLBoolean
 dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy;
    const __DRIconfig *config;
-   uint32_t id, types;
+   uint32_t types;
    int i;
    static const unsigned int argb_masks[4] =
       { 0xff0000, 0xff00, 0xff, 0xff000000 };
    static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
 
    drv->API.CreateWindowSurface = dri2_create_window_surface;
-   drv->API.CreatePixmapSurface = dri2_create_pixmap_surface;
    drv->API.DestroySurface = dri2_destroy_surface;
    drv->API.SwapBuffers = dri2_swap_buffers;
-   drv->API.CreateImageKHR = dri2_wayland_create_image_khr;
    drv->API.Terminate = dri2_terminate;
 
    dri2_dpy = malloc(sizeof *dri2_dpy);
@@ -829,22 +743,19 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
       dri2_dpy->wl_dpy = disp->PlatformDisplay;
    }
 
-   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
-   if (id == 0)
-      wl_display_roundtrip(dri2_dpy->wl_dpy);
-   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
-   if (id == 0)
+   dri2_dpy->wl_queue = wl_display_create_queue(dri2_dpy->wl_dpy);
+   dri2_dpy->wl_registry = wl_display_get_registry(dri2_dpy->wl_dpy);
+   wl_proxy_set_queue((struct wl_proxy *) dri2_dpy->wl_registry,
+                      dri2_dpy->wl_queue);
+   wl_registry_add_listener(dri2_dpy->wl_registry,
+                            &registry_listener, dri2_dpy);
+   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->wl_drm == NULL)
       goto cleanup_dpy;
-   dri2_dpy->wl_drm = wl_display_bind(dri2_dpy->wl_dpy, id, &wl_drm_interface);
-   if (!dri2_dpy->wl_drm)
-      goto cleanup_dpy;
-   wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
-   if (dri2_dpy->fd == -1)
+
+   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
       goto cleanup_drm;
 
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
-   if (!dri2_dpy->authenticated)
+   if (roundtrip(dri2_dpy) < 0 || !dri2_dpy->authenticated)
       goto cleanup_fd;
 
    dri2_dpy->driver_name = dri2_get_driver_for_fd(dri2_dpy->fd);
@@ -871,7 +782,7 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    if (!dri2_create_screen(disp))
       goto cleanup_driver;
 
-   types = EGL_WINDOW_BIT | EGL_PIXMAP_BIT;
+   types = EGL_WINDOW_BIT;
    for (i = 0; dri2_dpy->driver_configs[i]; i++) {
       config = dri2_dpy->driver_configs[i];
       if (dri2_dpy->formats & HAS_XRGB8888)
@@ -880,8 +791,6 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
 	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
    }
 
-   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
-
    disp->Extensions.WL_bind_wayland_display = EGL_TRUE;
    dri2_dpy->authenticate = dri2_wayland_authenticate;
 
diff --git a/src/egl/main/eglcontext.c b/src/egl/main/eglcontext.c
index 71eca6f..4efb76b 100644
--- a/src/egl/main/eglcontext.c
+++ b/src/egl/main/eglcontext.c
@@ -229,17 +229,14 @@ _eglParseContextAttribList(_EGLContext *ctx, _EGLDisplay *dpy,
              *
              *     "* If an OpenGL context is requested, the requested version
              *        is greater than 3.2, and the value for attribute
-             *        EGL_CONTEXT_PROFILE_MASK_KHR has no bits set; has any
-             *        bits set other than EGL_CONTEXT_CORE_PROFILE_BIT_KHR and
-             *        EGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_KHR; has more than
-             *        one of these bits set; or if the implementation does not
-             *        support the requested profile, then an
-             *        EGL_BAD_PROFILE_KHR error is generated."
-             *
-             * However, it does not define EGL_BAD_PROFILE_KHR.  For now use
-             * EGL_BAD_ATTRIBUTE.
+             *        EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR has no bits set; has
+             *        any bits set other than EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR
+             *        and EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR; has
+             *        more than one of these bits set; or if the implementation does
+             *        not support the requested profile, then an EGL_BAD_MATCH error
+             *        is generated."
              */
-            err = EGL_BAD_ATTRIBUTE;
+            err = EGL_BAD_MATCH;
             break;
          }
       }
diff --git a/src/egl/wayland/wayland-drm/wayland-drm.c b/src/egl/wayland/wayland-drm/wayland-drm.c
index 45b307f..d02aab6 100644
--- a/src/egl/wayland/wayland-drm/wayland-drm.c
+++ b/src/egl/wayland/wayland-drm/wayland-drm.c
@@ -36,17 +36,6 @@
 #include "wayland-drm.h"
 #include "wayland-drm-server-protocol.h"
 
-/* Git master of Wayland is moving towards a stable version of the
- * protocol, but breaking from 0.85 in the process.  For the time
- * being, it's convenient to be able to build Mesa against both master
- * and 0.85.x of Wayland.  To make this work we'll do a compile-time
- * version check and work around the difference in API and protocol */
-#if defined (WAYLAND_VERSION_MAJOR) &&		\
-	WAYLAND_VERSION_MAJOR == 0 &&		\
-	WAYLAND_VERSION_MINOR == 85
-#define HAS_WAYLAND_0_85
-#endif
-
 struct wl_drm {
 	struct wl_display *display;
 
@@ -69,25 +58,10 @@ destroy_buffer(struct wl_resource *resource)
 static void
 buffer_destroy(struct wl_client *client, struct wl_resource *resource)
 {
-#ifdef HAS_WAYLAND_0_85
-	wl_resource_destroy(resource, 0);
-#else
 	wl_resource_destroy(resource);
-#endif
-}
-
-#ifdef HAS_WAYLAND_0_85
-static void
-buffer_damage(struct wl_client *client, struct wl_resource *buffer,
-              int32_t x, int32_t y, int32_t width, int32_t height)
-{
 }
-#endif
 
 const static struct wl_buffer_interface drm_buffer_interface = {
-#ifdef HAS_WAYLAND_0_85
-	buffer_damage,
-#endif
 	buffer_destroy
 };
 
diff --git a/src/egl/wayland/wayland-egl/wayland-egl-priv.h b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
index accd2dd..bdbf32a 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl-priv.h
+++ b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
@@ -26,17 +26,6 @@ struct wl_egl_window {
 	int attached_height;
 };
 
-struct wl_egl_pixmap {
-	struct wl_buffer *buffer;
-
-	int width;
-	int height;
-
-	void (*destroy) (struct wl_egl_pixmap *egl_pixmap);
-
-	void *driver_private;
-};
-
 #ifdef  __cplusplus
 }
 #endif
diff --git a/src/egl/wayland/wayland-egl/wayland-egl.c b/src/egl/wayland/wayland-egl/wayland-egl.c
index e950b4a..c61fb4f 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl.c
+++ b/src/egl/wayland/wayland-egl/wayland-egl.c
@@ -48,36 +48,3 @@ wl_egl_window_get_attached_size(struct wl_egl_window *egl_window,
 	if (height)
 		*height = egl_window->attached_height;
 }
-
-WL_EGL_EXPORT struct wl_egl_pixmap *
-wl_egl_pixmap_create(int width, int height, uint32_t flags)
-{
-	struct wl_egl_pixmap *egl_pixmap;
-
-	egl_pixmap = malloc(sizeof *egl_pixmap);
-	if (egl_pixmap == NULL)
-		return NULL;
-
-	egl_pixmap->width   = width;
-	egl_pixmap->height  = height;
-
-	egl_pixmap->destroy = NULL;
-	egl_pixmap->buffer  = NULL;
-	egl_pixmap->driver_private = NULL;
-
-	return egl_pixmap;
-}
-
-WL_EGL_EXPORT void
-wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-	if (egl_pixmap->destroy)
-		egl_pixmap->destroy(egl_pixmap);
-	free(egl_pixmap);
-}
-
-WL_EGL_EXPORT struct wl_buffer *
-wl_egl_pixmap_create_buffer(struct wl_egl_pixmap *egl_pixmap)
-{
-	return egl_pixmap->buffer;
-}
diff --git a/src/gallium/drivers/nv30/nv30_miptree.c b/src/gallium/drivers/nv30/nv30_miptree.c
index 7e67729..18e40e1 100644
--- a/src/gallium/drivers/nv30/nv30_miptree.c
+++ b/src/gallium/drivers/nv30/nv30_miptree.c
@@ -56,8 +56,7 @@ nv30_miptree_get_handle(struct pipe_screen *pscreen,
    if (!mt || !mt->base.bo)
       return FALSE;
 
-   stride = util_format_get_stride(mt->base.base.format,
-                                   mt->base.base.width0);
+   stride = mt->level[0].pitch;
 
    return nouveau_screen_bo_get_handle(pscreen, mt->base.bo, stride, handle);
 }
diff --git a/src/gallium/drivers/nv50/nv50_miptree.c b/src/gallium/drivers/nv50/nv50_miptree.c
index 7b8dfb8..70e8c77 100644
--- a/src/gallium/drivers/nv50/nv50_miptree.c
+++ b/src/gallium/drivers/nv50/nv50_miptree.c
@@ -133,8 +133,7 @@ nv50_miptree_get_handle(struct pipe_screen *pscreen,
    if (!mt || !mt->base.bo)
       return FALSE;
 
-   stride = util_format_get_stride(mt->base.base.format,
-                                   mt->base.base.width0);
+   stride = mt->level[0].pitch;
 
    return nouveau_screen_bo_get_handle(pscreen,
                                        mt->base.bo,
diff --git a/src/gallium/state_trackers/egl/wayland/native_drm.c b/src/gallium/state_trackers/egl/wayland/native_drm.c
index c6f6197..4671e33 100644
--- a/src/gallium/state_trackers/egl/wayland/native_drm.c
+++ b/src/gallium/state_trackers/egl/wayland/native_drm.c
@@ -182,35 +182,43 @@ static const struct wl_drm_listener drm_listener = {
    drm_handle_authenticated
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+                       const char *interface, uint32_t version)
+{
+   struct wayland_drm_display *drmdpy = data;
+
+   if (strcmp(interface, "wl_drm") == 0) {
+      drmdpy->wl_drm = wl_registry_bind(registry, name, &wl_drm_interface, 1);
+      wl_drm_add_listener(drmdpy->wl_drm, &drm_listener, drmdpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+       registry_handle_global
+};
+
 static boolean
 wayland_drm_display_init_screen(struct native_display *ndpy)
 {
    struct wayland_drm_display *drmdpy = wayland_drm_display(ndpy);
-   uint32_t id;
-
-   id = wl_display_get_global(drmdpy->base.dpy, "wl_drm", 1);
-   if (id == 0)
-      wl_display_roundtrip(drmdpy->base.dpy);
-   id = wl_display_get_global(drmdpy->base.dpy, "wl_drm", 1);
-   if (id == 0)
-      return FALSE;
 
-   drmdpy->wl_drm = wl_display_bind(drmdpy->base.dpy, id, &wl_drm_interface);
-   if (!drmdpy->wl_drm)
+   drmdpy->base.queue = wl_display_create_queue(drmdpy->base.dpy);
+   drmdpy->base.registry = wl_display_get_registry(drmdpy->base.dpy);
+   wl_proxy_set_queue((struct wl_proxy *) drmdpy->base.registry,
+                      drmdpy->base.queue);
+   wl_registry_add_listener(drmdpy->base.registry, &registry_listener, drmdpy);
+   if (wayland_roundtrip(&drmdpy->base) < 0 || drmdpy->wl_drm == NULL)
       return FALSE;
 
    wl_drm_add_listener(drmdpy->wl_drm, &drm_listener, drmdpy);
-   wl_display_roundtrip(drmdpy->base.dpy);
-   if (drmdpy->fd == -1)
+   if (wayland_roundtrip(&drmdpy->base) < 0 || drmdpy->fd == -1)
       return FALSE;
 
-   wl_display_roundtrip(drmdpy->base.dpy);
-   if (!drmdpy->authenticated)
+   if (wayland_roundtrip(&drmdpy->base) < 0 || !drmdpy->authenticated)
       return FALSE;
 
    if (drmdpy->base.formats == 0)
-      wl_display_roundtrip(drmdpy->base.dpy);
-   if (drmdpy->base.formats == 0)
       return FALSE;
 
    drmdpy->base.base.screen =
diff --git a/src/gallium/state_trackers/egl/wayland/native_shm.c b/src/gallium/state_trackers/egl/wayland/native_shm.c
index 574ffce..5ffe485 100644
--- a/src/gallium/state_trackers/egl/wayland/native_shm.c
+++ b/src/gallium/state_trackers/egl/wayland/native_shm.c
@@ -133,26 +133,36 @@ static const struct wl_shm_listener shm_listener = {
    shm_handle_format
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+                       const char *interface, uint32_t version)
+{
+   struct wayland_shm_display *shmdpy = data;
+
+   if (strcmp(interface, "wl_shm") == 0) {
+      shmdpy->wl_shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
+      wl_shm_add_listener(shmdpy->wl_shm, &shm_listener, shmdpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+       registry_handle_global
+};
+
 static boolean
 wayland_shm_display_init_screen(struct native_display *ndpy)
 {
    struct wayland_shm_display *shmdpy = wayland_shm_display(ndpy);
    struct sw_winsys *winsys = NULL;
-   uint32_t id;
 
-   id = wl_display_get_global(shmdpy->base.dpy, "wl_shm", 1);
-   if (id == 0)
-      wl_display_iterate(shmdpy->base.dpy, WL_DISPLAY_READABLE);
-   id = wl_display_get_global(shmdpy->base.dpy, "wl_shm", 1);
-   if (id == 0)
+   shmdpy->base.queue = wl_display_create_queue(shmdpy->base.dpy);
+   shmdpy->base.registry = wl_display_get_registry(shmdpy->base.dpy);
+   wl_proxy_set_queue((struct wl_proxy *) shmdpy->base.registry,
+                      shmdpy->base.queue);
+   wl_registry_add_listener(shmdpy->base.registry, &registry_listener, shmdpy);
+   if (wayland_roundtrip(&shmdpy->base) < 0 || shmdpy->wl_shm == NULL)
       return FALSE;
 
-   shmdpy->wl_shm = wl_display_bind(shmdpy->base.dpy, id, &wl_shm_interface);
-   if (!shmdpy->wl_shm)
-      return FALSE;
-
-   wl_shm_add_listener(shmdpy->wl_shm, &shm_listener, shmdpy);
-
    if (shmdpy->base.formats == 0)
       wl_display_roundtrip(shmdpy->base.dpy);
    if (shmdpy->base.formats == 0)
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.c b/src/gallium/state_trackers/egl/wayland/native_wayland.c
index a7f9cb7..62c87f3 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.c
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.c
@@ -35,6 +35,34 @@
 
 #include "native_wayland.h"
 
+static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+   int *done = data;
+
+   *done = 1;
+   wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+int
+wayland_roundtrip(struct wayland_display *display)
+{
+   struct wl_callback *callback;
+   int done = 0, ret = 0;
+
+   callback = wl_display_sync(display->dpy);
+   wl_callback_add_listener(callback, &sync_listener, &done);
+   wl_proxy_set_queue((struct wl_proxy *) callback, display->queue);
+   while (ret == 0 && !done)
+      ret = wl_display_dispatch_queue(display->dpy, display->queue);
+
+   return ret;
+}
+
 static const struct native_event_handler *wayland_event_handler;
 
 const static struct {
@@ -71,7 +99,6 @@ wayland_display_get_configs(struct native_display *ndpy, int *num_configs)
             (1 << NATIVE_ATTACHMENT_BACK_LEFT);
          
          nconf->window_bit = TRUE;
-         nconf->pixmap_bit = TRUE;
          
          nconf->color_format = wayland_formats[i].format;
          display->num_configs++;
@@ -93,7 +120,6 @@ static int
 wayland_display_get_param(struct native_display *ndpy,
                           enum native_param_type param)
 {
-   struct wayland_display *display = wayland_display(ndpy);
    int val;
 
    switch (param) {
@@ -111,49 +137,6 @@ wayland_display_get_param(struct native_display *ndpy,
    return val;
 }
 
-static boolean
-wayland_display_get_pixmap_format(struct native_display *ndpy,
-                                  EGLNativePixmapType pix,
-                                  enum pipe_format *format)
-{
-   /* all wl_egl_pixmaps are supported */
-   *format = PIPE_FORMAT_NONE;
-
-   return TRUE;
-}
-
-static void
-wayland_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct pipe_resource *resource = egl_pixmap->driver_private;
-
-   assert(resource);
-
-   pipe_resource_reference(&resource, NULL);
-   if (egl_pixmap->buffer) {
-      wl_buffer_destroy(egl_pixmap->buffer);
-      egl_pixmap->buffer = NULL;
-   }
-
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
-static void
-wayland_pixmap_surface_initialize(struct wayland_surface *surface)
-{
-   struct wayland_display *display = wayland_display(&surface->display->base);
-   const enum native_attachment front_natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-
-   if (surface->pix->buffer != NULL)
-      return;
-
-   surface->pix->buffer  = display->create_buffer(display, surface, front_natt);
-   surface->pix->destroy = wayland_pixmap_destroy;
-   surface->pix->driver_private =
-      resource_surface_get_single_resource(surface->rsurf, front_natt);
-}
-
 static void
 wayland_release_pending_resource(void *data,
                                  struct wl_callback *callback,
@@ -188,7 +171,7 @@ wayland_window_surface_handle_resize(struct wayland_surface *surface)
                                  surface->win->width, surface->win->height)) {
 
       if (surface->pending_resource)
-         wl_display_roundtrip(display->dpy);
+         wayland_roundtrip(display);
 
       if (front_resource) {
          struct wl_callback *callback;
@@ -198,6 +181,7 @@ wayland_window_surface_handle_resize(struct wayland_surface *surface)
 
          callback = wl_display_sync(display->dpy);
          wl_callback_add_listener(callback, &release_buffer_listener, surface);
+         wl_proxy_set_queue((struct wl_proxy *) callback, display->queue);
       }
 
       for (i = 0; i < WL_BUFFER_COUNT; ++i) {
@@ -234,9 +218,6 @@ wayland_surface_validate(struct native_surface *nsurf, uint attachment_mask,
 
    resource_surface_get_size(surface->rsurf, (uint *) width, (uint *) height);
 
-   if (surface->type == WL_PIXMAP_SURFACE)
-      wayland_pixmap_surface_initialize(surface);
-
    return TRUE;
 }
 
@@ -245,7 +226,7 @@ wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
 {
    struct wayland_surface *surface = data;
 
-   surface->block_swap_buffers = FALSE;
+   surface->frame_callback = NULL;
 
    wl_callback_destroy(callback);
 }
@@ -269,15 +250,17 @@ wayland_surface_swap_buffers(struct native_surface *nsurf)
 {
    struct wayland_surface *surface = wayland_surface(nsurf);
    struct wayland_display *display = surface->display;
-   struct wl_callback *callback;
+   int ret = 0;
 
-   while (surface->block_swap_buffers)
-      wl_display_iterate(display->dpy, WL_DISPLAY_READABLE);
+   while (surface->frame_callback && ret != -1)
+      ret = wl_display_dispatch_queue(display->dpy, display->queue);
+   if (ret == -1)
+      return EGL_FALSE;
 
-   surface->block_swap_buffers = TRUE;
-
-   callback = wl_surface_frame(surface->win->surface);
-   wl_callback_add_listener(callback, &frame_listener, surface);
+   surface->frame_callback = wl_surface_frame(surface->win->surface);
+   wl_callback_add_listener(surface->frame_callback, &frame_listener, surface);
+   wl_proxy_set_queue((struct wl_proxy *) surface->frame_callback,
+                      display->queue);
 
    if (surface->type == WL_WINDOW_SURFACE) {
       resource_surface_swap_buffers(surface->rsurf,
@@ -349,6 +332,7 @@ wayland_surface_present(struct native_surface *nsurf,
    if (surface->type == WL_WINDOW_SURFACE) {
       resource_surface_get_size(surface->rsurf, &width, &height);
       wl_surface_damage(surface->win->surface, 0, 0, width, height);
+      wl_surface_commit(surface->win->surface);
    }
 
    return ret;
@@ -376,61 +360,6 @@ wayland_surface_destroy(struct native_surface *nsurf)
 }
 
 
-
-static struct native_surface *
-wayland_create_pixmap_surface(struct native_display *ndpy,
-                              EGLNativePixmapType pix,
-                              const struct native_config *nconf)
-{
-   struct wayland_display *display = wayland_display(ndpy);
-   struct wayland_surface *surface;
-   struct wl_egl_pixmap *egl_pixmap = (struct wl_egl_pixmap *) pix;
-   enum native_attachment natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-   uint bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW |
-      PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT;
-
-   surface = CALLOC_STRUCT(wayland_surface);
-   if (!surface)
-      return NULL;
-
-   surface->display = display;
-
-   surface->pending_resource = NULL;
-   surface->type = WL_PIXMAP_SURFACE;
-   surface->pix = egl_pixmap;
-
-   if (nconf)
-      surface->color_format = nconf->color_format;
-   else /* FIXME: derive format from wl_visual */
-      surface->color_format = PIPE_FORMAT_B8G8R8A8_UNORM;
-
-   surface->attachment_mask = (1 << NATIVE_ATTACHMENT_FRONT_LEFT);
-
-   surface->rsurf = resource_surface_create(display->base.screen,
-                                            surface->color_format, bind);
-
-   if (!surface->rsurf) {
-      FREE(surface);
-      return NULL;
-   }
-
-   resource_surface_set_size(surface->rsurf,
-                             egl_pixmap->width, egl_pixmap->height);
-
-   /* the pixmap is already allocated, so import it */
-   if (surface->pix->buffer != NULL)
-      resource_surface_import_resource(surface->rsurf, natt,
-                                       surface->pix->driver_private);
-
-   surface->base.destroy = wayland_surface_destroy;
-   surface->base.present = wayland_surface_present;
-   surface->base.validate = wayland_surface_validate;
-   surface->base.wait = wayland_surface_wait;
-
-   return &surface->base;
-}
-
-
 static struct native_surface *
 wayland_create_window_surface(struct native_display *ndpy,
                               EGLNativeWindowType win,
@@ -452,7 +381,7 @@ wayland_create_window_surface(struct native_display *ndpy,
    surface->win = (struct wl_egl_window *) win;
 
    surface->pending_resource = NULL;
-   surface->block_swap_buffers = FALSE;
+   surface->frame_callback = NULL;
    surface->type = WL_WINDOW_SURFACE;
 
    surface->buffer[WL_BUFFER_FRONT] = NULL;
@@ -505,10 +434,7 @@ native_create_display(void *dpy, boolean use_sw)
 
    display->base.get_param = wayland_display_get_param;
    display->base.get_configs = wayland_display_get_configs;
-   display->base.get_pixmap_format = wayland_display_get_pixmap_format;
-   display->base.copy_to_pixmap = native_display_copy_to_pixmap;
    display->base.create_window_surface = wayland_create_window_surface;
-   display->base.create_pixmap_surface = wayland_create_pixmap_surface;
 
    display->own_dpy = own_dpy;
 
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.h b/src/gallium/state_trackers/egl/wayland/native_wayland.h
index e6a914f..b623fee 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.h
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.h
@@ -45,6 +45,8 @@ struct wayland_display {
    struct native_display base;
 
    struct wl_display *dpy;
+   struct wl_event_queue *queue;
+   struct wl_registry *registry;
    boolean own_dpy;
    /* supported formats */
    uint32_t formats;
@@ -65,7 +67,6 @@ enum wayland_buffer_type {
 
 enum wayland_surface_type {
    WL_WINDOW_SURFACE,
-   WL_PIXMAP_SURFACE,
    WL_PBUFFER_SURFACE
 };
 
@@ -74,7 +75,6 @@ struct wayland_surface {
    struct wayland_display *display;
 
    struct wl_egl_window *win;
-   struct wl_egl_pixmap *pix;
    enum wayland_surface_type type;
    int dx, dy;
    struct resource_surface *rsurf;
@@ -85,7 +85,7 @@ struct wayland_surface {
    struct wl_buffer *buffer[WL_BUFFER_COUNT];
    unsigned int attachment_mask;
 
-   boolean block_swap_buffers;
+   struct wl_callback *frame_callback;
    boolean premultiplied_alpha;
 };
 
@@ -119,4 +119,7 @@ struct wayland_display *
 wayland_create_drm_display(struct wl_display *display,
                            const struct native_event_handler *event_handler);
 
+int
+wayland_roundtrip(struct wayland_display *drmdpy);
+
 #endif /* _NATIVE_WAYLAND_H_ */
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index d8b1cc7..519929e 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -33,8 +33,10 @@
 #include <limits.h>
 
 #include <sys/types.h>
+#include <sys/mman.h>
 #include <unistd.h>
 #include <dlfcn.h>
+#include <xf86drm.h>
 
 #include <GL/gl.h> /* dri_interface needs GL types */
 #include <GL/internal/dri_interface.h>
@@ -300,19 +302,12 @@ static int
 gbm_dri_bo_write(struct gbm_bo *_bo, const void *buf, size_t count)
 {
    struct gbm_dri_bo *bo = gbm_dri_bo(_bo);
-   void *ptr;
-   int ret;
-
-   if (bo->bo == NULL)
-      return -1;
 
-   ret = kms_bo_map(bo->bo, &ptr);
-   if (ret < 0)
+   if (bo->image != NULL)
       return -1;
 
-   memcpy(ptr, buf, count);
+   memcpy(bo->map, buf, count);
 
-   kms_bo_unmap(bo->bo);
    return 0;
 }
 
@@ -321,11 +316,17 @@ gbm_dri_bo_destroy(struct gbm_bo *_bo)
 {
    struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);
    struct gbm_dri_bo *bo = gbm_dri_bo(_bo);
+   struct drm_mode_destroy_dumb arg;
 
-   if (bo->image != NULL)
+   if (bo->image != NULL) {
       dri->image->destroyImage(bo->image);
-   if (bo->bo != NULL)
-      kms_bo_destroy(&bo->bo);
+   } else {
+      munmap(bo->map, bo->size);
+      memset(&arg, 0, sizeof(arg));
+      arg.handle = bo->handle;
+      drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
+   }
+
    free(bo);
 }
 
@@ -375,6 +376,9 @@ gbm_dri_bo_import(struct gbm_device *gbm,
    {
       struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;
 
+      if (!wayland_buffer_is_drm(buffer))
+         return NULL;
+
       image = wb->driver_buffer;
 
       switch (wb->format) {
@@ -445,49 +449,86 @@ gbm_dri_bo_import(struct gbm_device *gbm,
 }
 
 static struct gbm_bo *
-gbm_dri_bo_create(struct gbm_device *gbm,
+create_dumb(struct gbm_device *gbm,
                   uint32_t width, uint32_t height,
                   uint32_t format, uint32_t usage)
 {
    struct gbm_dri_device *dri = gbm_dri_device(gbm);
+   struct drm_mode_create_dumb create_arg;
+   struct drm_mode_map_dumb map_arg;
    struct gbm_dri_bo *bo;
-   int dri_format;
-   unsigned dri_use = 0;
+   struct drm_mode_destroy_dumb destroy_arg;
+   int ret;
+
+   if (!(usage & GBM_BO_USE_CURSOR_64X64))
+      return NULL;
+   if (format != GBM_FORMAT_ARGB8888)
+      return NULL;
 
    bo = calloc(1, sizeof *bo);
    if (bo == NULL)
       return NULL;
 
+   create_arg.bpp = 32;
+   create_arg.width = width;
+   create_arg.height = height;
+
+   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
+   if (ret)
+      goto free_bo;
+
    bo->base.base.gbm = gbm;
    bo->base.base.width = width;
    bo->base.base.height = height;
+   bo->base.base.stride = create_arg.pitch;
+   bo->base.base.handle.u32 = create_arg.handle;
+   bo->handle = create_arg.handle;
+   bo->size = create_arg.size;
 
-   if (usage & GBM_BO_USE_WRITE) {
-      int ret;
-      unsigned attrs[7] = {
-         KMS_WIDTH, 64,
-         KMS_HEIGHT, 64,
-         KMS_BO_TYPE, KMS_BO_TYPE_SCANOUT_X8R8G8B8,
-         KMS_TERMINATE_PROP_LIST,
-      };
+   memset(&map_arg, 0, sizeof(map_arg));
+   map_arg.handle = bo->handle;
 
-      if (!(usage & GBM_BO_USE_CURSOR_64X64))
-         return NULL;
+   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
+   if (ret)
+      goto destroy_dumb;
 
-      if (dri->kms == NULL)
-         return NULL;
+   bo->map = mmap(0, bo->size, PROT_WRITE,
+                  MAP_SHARED, dri->base.base.fd, map_arg.offset);
+   if (bo->map == MAP_FAILED)
+      goto destroy_dumb;
 
-      ret = kms_bo_create(dri->kms, attrs, &bo->bo);
-      if (ret < 0) {
-         free(bo);
-         return NULL;
-      }
+   return &bo->base.base;
 
-      kms_bo_get_prop(bo->bo, KMS_PITCH, &bo->base.base.stride);
-      kms_bo_get_prop(bo->bo, KMS_HANDLE, (unsigned*)&bo->base.base.handle);
+destroy_dumb:
+   memset(&destroy_arg, 0, sizeof destroy_arg);
+   destroy_arg.handle = create_arg.handle;
+   drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
+free_bo:
+   free(bo);
 
-      return &bo->base.base;
-   }
+   return NULL;
+}
+
+static struct gbm_bo *
+gbm_dri_bo_create(struct gbm_device *gbm,
+                  uint32_t width, uint32_t height,
+                  uint32_t format, uint32_t usage)
+{
+   struct gbm_dri_device *dri = gbm_dri_device(gbm);
+   struct gbm_dri_bo *bo;
+   int dri_format;
+   unsigned dri_use = 0;
+
+   if (usage & GBM_BO_USE_WRITE)
+      return create_dumb(gbm, width, height, format, usage);
+
+   bo = calloc(1, sizeof *bo);
+   if (bo == NULL)
+      return NULL;
+
+   bo->base.base.gbm = gbm;
+   bo->base.base.width = width;
+   bo->base.base.height = height;
 
    switch (format) {
    case GBM_FORMAT_RGB565:
@@ -594,10 +635,6 @@ dri_device_create(int fd)
    dri->base.type = GBM_DRM_DRIVER_TYPE_DRI;
    dri->base.base.name = "drm";
 
-   kms_create(fd, &dri->kms);
-   if (dri->kms == NULL)
-      goto err_kms;
-
    ret = dri_screen_create(dri);
    if (ret)
       goto err_dri;
@@ -605,9 +642,8 @@ dri_device_create(int fd)
    return &dri->base.base;
 
 err_dri:
-   kms_destroy(&dri->kms);
-err_kms:
    free(dri);
+
    return NULL;
 }
 
diff --git a/src/gbm/backends/dri/gbm_driint.h b/src/gbm/backends/dri/gbm_driint.h
index 4b619a0..18fc3c0 100644
--- a/src/gbm/backends/dri/gbm_driint.h
+++ b/src/gbm/backends/dri/gbm_driint.h
@@ -30,8 +30,6 @@
 
 #include "gbmint.h"
 
-#include "libkms.h"
-
 #include "common.h"
 #include "common_drm.h"
 
@@ -43,9 +41,6 @@ struct gbm_dri_surface;
 struct gbm_dri_device {
    struct gbm_drm_device base;
 
-   /* Only used for cursors */
-   struct kms_driver *kms;
-
    void *driver;
 
    __DRIscreen *screen;
@@ -79,7 +74,8 @@ struct gbm_dri_bo {
    __DRIimage *image;
 
    /* Only used for cursors */
-   struct kms_bo *bo;
+   uint32_t handle, size;
+   void *map;
 };
 
 struct gbm_dri_surface {
diff --git a/src/glsl/linker.cpp b/src/glsl/linker.cpp
index 34ce133..86371b5 100644
--- a/src/glsl/linker.cpp
+++ b/src/glsl/linker.cpp
@@ -882,6 +882,7 @@ move_non_declarations(exec_list *instructions, exec_node *last,
 
       assert(inst->as_assignment()
              || inst->as_call()
+             || inst->as_if() /* for initializers with the ?: operator */
 	     || ((var != NULL) && (var->mode == ir_var_temporary)));
 
       if (make_copies) {
diff --git a/src/glsl/ralloc.c b/src/glsl/ralloc.c
index 3da09b5..59e71c4 100644
--- a/src/glsl/ralloc.c
+++ b/src/glsl/ralloc.c
@@ -41,14 +41,6 @@ _CRTIMP int _vscprintf(const char *format, va_list argptr);
 
 #include "ralloc.h"
 
-#ifdef __GNUC__
-#define likely(x)       __builtin_expect(!!(x),1)
-#define unlikely(x)     __builtin_expect(!!(x),0)
-#else
-#define likely(x)       !!(x)
-#define unlikely(x)     !!(x)
-#endif
-
 #ifndef va_copy
 #ifdef __va_copy
 #define va_copy(dest, src) __va_copy((dest), (src))
diff --git a/src/glsl/ralloc.h b/src/glsl/ralloc.h
index 86306b1..67eb938 100644
--- a/src/glsl/ralloc.h
+++ b/src/glsl/ralloc.h
@@ -54,6 +54,7 @@ extern "C" {
 #include <stddef.h>
 #include <stdarg.h>
 #include <stdbool.h>
+#include "main/compiler.h"
 
 /**
  * \def ralloc(ctx, type)
@@ -301,7 +302,7 @@ bool ralloc_strncat(char **dest, const char *str, size_t n);
  *
  * \return The newly allocated string.
  */
-char *ralloc_asprintf (const void *ctx, const char *fmt, ...);
+char *ralloc_asprintf (const void *ctx, const char *fmt, ...) PRINTFLIKE(2, 3);
 
 /**
  * Print to a string, given a va_list.
@@ -334,7 +335,8 @@ char *ralloc_vasprintf(const void *ctx, const char *fmt, va_list args);
  * \return True unless allocation failed.
  */
 bool ralloc_asprintf_rewrite_tail(char **str, size_t *start,
-				  const char *fmt, ...);
+				  const char *fmt, ...)
+				  PRINTFLIKE(3, 4);
 
 /**
  * Rewrite the tail of an existing string, starting at a given index.
@@ -376,7 +378,8 @@ bool ralloc_vasprintf_rewrite_tail(char **str, size_t *start, const char *fmt,
  *
  * \return True unless allocation failed.
  */
-bool ralloc_asprintf_append (char **str, const char *fmt, ...);
+bool ralloc_asprintf_append (char **str, const char *fmt, ...)
+			     PRINTFLIKE(2, 3);
 
 /**
  * Append formatted text to the supplied string, given a va_list.
diff --git a/src/glsl/tests/Makefile.am b/src/glsl/tests/Makefile.am
index ee3cef6..957bb55 100644
--- a/src/glsl/tests/Makefile.am
+++ b/src/glsl/tests/Makefile.am
@@ -1,12 +1,9 @@
-INC = \
+AM_CPPFLAGS = \
 	-I$(top_builddir)/src/gtest/include \
 	-I$(top_builddir)/src/mesa \
 	-I$(top_builddir)/src/mapi \
 	-I$(top_builddir)/src/glsl
 
-AM_CFLAGS =  $(INC)
-AM_CXXFLAGS = $(INC)
-
 TESTS_ENVIRONMENT= \
 	export PYTHON2=$(PYTHON2); \
 	export PYTHON_FLAGS=$(PYTHON_FLAGS);
diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index 4e8b351..15f590e 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -961,7 +961,7 @@ dri2BindExtensions(struct dri2_screen *psc, const __DRIextension **extensions)
    __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");
 
    /* FIXME: if DRI2 version supports it... */
-   __glXEnableDirectExtension(&psc->base, "INTEL_swap_event");
+   __glXEnableDirectExtension(&psc->base, "GLX_INTEL_swap_event");
 
    if (psc->dri2->base.version >= 3) {
       const unsigned mask = psc->dri2->getAPIMask(psc->driScreen);
diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index a4e76c1..420e677 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -83,6 +83,7 @@ static /* const */ char *error_list[] = {
    "GLXBadPbuffer",
    "GLXBadCurrentDrawable",
    "GLXBadWindow",
+   "GLXBadProfileARB",
 };
 
 #ifdef GLX_USE_APPLEGL
@@ -404,6 +405,8 @@ __glXInitializeVisualConfigFromTags(struct glx_config * config, int count,
 #endif
    }
 
+   config->sRGBCapable = GL_FALSE;
+
    /*
     ** Additional properties may be in a list at the end
     ** of the reply.  They are in pairs of property type
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 751a18f..f83a7a7 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -2981,7 +2981,6 @@
     <enum name="POLYGON_OFFSET_FACTOR"         count="1"  value="0x8038">
         <size name="Get" mode="get"/>
     </enum>
-    <enum name="POLYGON_OFFSET_BIAS"                      value="0x8039"/>
     <enum name="ALPHA4"                                   value="0x803B"/>
     <enum name="ALPHA8"                                   value="0x803C"/>
     <enum name="ALPHA12"                                  value="0x803D"/>
@@ -8089,6 +8088,8 @@
 </category>
 
 <category name="GL_EXT_polygon_offset" number="3">
+    <enum name="POLYGON_OFFSET_BIAS_EXT"                  value="0x8039"/>
+
     <function name="PolygonOffsetEXT" offset="assign">
         <param name="factor" type="GLfloat"/>
         <param name="bias" type="GLfloat"/>
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 6dfa08e..4799af2 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -413,8 +413,10 @@ static void emit_depthbuffer(struct brw_context *brw)
        * tile_x and tile_y to 0.  This is a temporary workaround until we come
        * up with a better solution.
        */
-      tile_x &= ~7;
-      tile_y &= ~7;
+      if (intel->gen >= 6) {
+         tile_x &= ~7;
+         tile_y &= ~7;
+      }
 
       BEGIN_BATCH(len);
       OUT_BATCH(_3DSTATE_DEPTH_BUFFER << 16 | (len - 2));
diff --git a/src/mesa/drivers/dri/intel/intel_screen.c b/src/mesa/drivers/dri/intel/intel_screen.c
index f96583c..00a1b01 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.c
+++ b/src/mesa/drivers/dri/intel/intel_screen.c
@@ -26,6 +26,7 @@
  **************************************************************************/
 
 #include <errno.h>
+#include <time.h>
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index c0e6bc7..a21ae10 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -404,9 +404,6 @@ one_time_init( struct gl_context *ctx )
 
       _mesa_get_cpu_features();
 
-      /* context dependence is never a one-time thing... */
-      _mesa_init_get_hash(ctx);
-
       for (i = 0; i < 256; i++) {
          _mesa_ubyte_to_float_color_tab[i] = (float) i / 255.0F;
       }
@@ -425,6 +422,8 @@ one_time_init( struct gl_context *ctx )
 
    /* per-API one-time init */
    if (!(api_init_mask & (1 << ctx->API))) {
+      _mesa_init_get_hash(ctx);
+
       /*
        * This is fine as ES does not use the remap table, but it may not be
        * future-proof.  We cannot always initialize the remap table because
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index fe1035b..e2ccc29 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -538,6 +538,11 @@ static const struct value_desc values[] = {
    /* GL_{APPLE,ARB,OES}_vertex_array_object */
    { GL_VERTEX_ARRAY_BINDING_APPLE, ARRAY_INT(Name), NO_EXTRA },
 
+   /* GL_EXT_texture_filter_anisotropic */
+   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
+     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
+     extra_EXT_texture_filter_anisotropic },
+
 #if FEATURE_GL || FEATURE_ES1
    /* Enums in OpenGL and GLES1 */
    { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES_BIT | API_OPENGL_CORE_BIT, NO_EXTRA },
@@ -687,11 +692,6 @@ static const struct value_desc values[] = {
    /* GL_EXT_texture_lod_bias */
    { GL_MAX_TEXTURE_LOD_BIAS_EXT, CONTEXT_FLOAT(Const.MaxTextureLodBias),
      NO_EXTRA },
-
-   /* GL_EXT_texture_filter_anisotropic */
-   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
-     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
-     extra_EXT_texture_filter_anisotropic },
 #endif /* FEATURE_GL || FEATURE_ES1 */
 
 #if FEATURE_ES1
@@ -791,6 +791,15 @@ static const struct value_desc values[] = {
 
 #endif /* FEATURE_GL || FEATURE_ES2 */
 
+#if FEATURE_ES1 || FEATURE_ES2
+   { 0, 0, TYPE_API_MASK, API_OPENGLES | API_OPENGLES2_BIT, NO_EXTRA },
+   /* GL_OES_EGL_image_external */
+   { GL_TEXTURE_BINDING_EXTERNAL_OES, LOC_CUSTOM,
+     TYPE_INT, TEXTURE_EXTERNAL_INDEX, extra_OES_EGL_image_external },
+   { GL_TEXTURE_EXTERNAL_OES, LOC_CUSTOM,
+     TYPE_BOOLEAN, 0, extra_OES_EGL_image_external },
+#endif
+
 #if FEATURE_ES2
    /* Enums unique to OpenGL ES 2.0 */
    { 0, 0, TYPE_API_MASK, API_OPENGLES2_BIT, NO_EXTRA },
@@ -803,12 +812,6 @@ static const struct value_desc values[] = {
    { GL_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
 #endif /* FEATURE_ES2 */
 
-   /* GL_OES_EGL_image_external */
-   { GL_TEXTURE_BINDING_EXTERNAL_OES, LOC_CUSTOM,
-     TYPE_INT, TEXTURE_EXTERNAL_INDEX, extra_OES_EGL_image_external },
-   { GL_TEXTURE_EXTERNAL_OES, LOC_CUSTOM,
-     TYPE_BOOLEAN, 0, extra_OES_EGL_image_external },
-
 #if FEATURE_GL
    /* Remaining enums are only in OpenGL */
    { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGL_CORE_BIT, NO_EXTRA },
@@ -1384,45 +1387,54 @@ static const struct value_desc values[] = {
  * collisions for any enum (typical numbers).  And the code is very
  * simple, even though it feels a little magic. */
 
-static unsigned short table[1024];
+static unsigned short table[API_LAST + 1][1024];
 static const int prime_factor = 89, prime_step = 281;
 
 #ifdef GET_DEBUG
 static void
-print_table_stats(void)
+print_table_stats(int api)
 {
    int i, j, collisions[11], count, hash, mask;
    const struct value_desc *d;
-
+   const char *api_names[] = {
+      [API_OPENGL] = "GL",
+      [API_OPENGL_CORE] = "GL_CORE",
+      [API_OPENGLES] = "GLES",
+      [API_OPENGLES2] = "GLES2",
+   };
+   const char *api_name;
+
+   api_name = api < Elements(api_names) ? api_names[api] : "N/A";
    count = 0;
-   mask = Elements(table) - 1;
+   mask = Elements(table[api]) - 1;
    memset(collisions, 0, sizeof collisions);
 
-   for (i = 0; i < Elements(table); i++) {
-      if (!table[i])
-	 continue;
+   for (i = 0; i < Elements(table[api]); i++) {
+      if (!table[api][i])
+         continue;
       count++;
-      d = &values[table[i]];
+      d = &values[table[api][i]];
       hash = (d->pname * prime_factor);
       j = 0;
       while (1) {
-	 if (values[table[hash & mask]].pname == d->pname)
-	    break;
-	 hash += prime_step;
-	 j++;
+         if (values[table[api][hash & mask]].pname == d->pname)
+            break;
+         hash += prime_step;
+         j++;
       }
 
       if (j < 10)
-	 collisions[j]++;
+         collisions[j]++;
       else
-	 collisions[10]++;
+         collisions[10]++;
    }
 
-   printf("number of enums: %d (total %d)\n", count, Elements(values));
+   printf("number of enums for %s: %d (total %ld)\n",
+         api_name, count, Elements(values));
    for (i = 0; i < Elements(collisions) - 1; i++)
       if (collisions[i] > 0)
-	 printf("  %d enums with %d %scollisions\n",
-		collisions[i], i, i == 10 ? "or more " : "");
+         printf("  %d enums with %d %scollisions\n",
+               collisions[i], i, i == 10 ? "or more " : "");
 }
 #endif
 
@@ -1437,27 +1449,30 @@ print_table_stats(void)
 void _mesa_init_get_hash(struct gl_context *ctx)
 {
    int i, hash, index, mask;
+   int api;
    int api_mask = 0, api_bit;
 
-   mask = Elements(table) - 1;
-   api_bit = 1 << ctx->API;
+   api = ctx->API;
+
+   mask = Elements(table[api]) - 1;
+   api_bit = 1 << api;
 
    for (i = 0; i < Elements(values); i++) {
       if (values[i].type == TYPE_API_MASK) {
-	 api_mask = values[i].offset;
-	 continue;
+         api_mask = values[i].offset;
+         continue;
       }
       if (!(api_mask & api_bit))
-	 continue;
+         continue;
 
       hash = (values[i].pname * prime_factor) & mask;
       while (1) {
-	 index = hash & mask;
-	 if (!table[index]) {
-	    table[index] = i;
-	    break;
-	 }
-	 hash += prime_step;
+         index = hash & mask;
+         if (!table[api][index]) {
+            table[api][index] = i;
+            break;
+         }
+         hash += prime_step;
       }
    }
 
@@ -1985,22 +2000,24 @@ find_value(const char *func, GLenum pname, void **p, union value *v)
    struct gl_texture_unit *unit;
    int mask, hash;
    const struct value_desc *d;
+   int api;
 
-   mask = Elements(table) - 1;
+   api = ctx->API;
+   mask = Elements(table[api]) - 1;
    hash = (pname * prime_factor);
    while (1) {
-      d = &values[table[hash & mask]];
+      d = &values[table[api][hash & mask]];
 
       /* If the enum isn't valid, the hash walk ends with index 0,
        * which is the API mask entry at the beginning of values[]. */
       if (unlikely(d->type == TYPE_API_MASK)) {
-	 _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
-                     _mesa_lookup_enum_by_nr(pname));
-	 return &error_value;
+         _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
+               _mesa_lookup_enum_by_nr(pname));
+         return &error_value;
       }
 
       if (likely(d->pname == pname))
-	 break;
+         break;
 
       hash += prime_step;
    }
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index ba43e57..f185ffd 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3340,6 +3340,8 @@ typedef enum
    API_OPENGLES,
    API_OPENGLES2,
    API_OPENGL_CORE,
+
+   API_LAST = API_OPENGL_CORE,
 } gl_api;
 
 /**
diff --git a/src/mesa/main/tests/enum_strings.cpp b/src/mesa/main/tests/enum_strings.cpp
index 7d46080..f4f424d 100644
--- a/src/mesa/main/tests/enum_strings.cpp
+++ b/src/mesa/main/tests/enum_strings.cpp
@@ -563,7 +563,7 @@ const struct enum_info everything[] = {
    { 0x8036, "GL_UNSIGNED_INT_10_10_10_2" },
    { 0x8037, "GL_POLYGON_OFFSET_FILL" },
    { 0x8038, "GL_POLYGON_OFFSET_FACTOR" },
-   { 0x8039, "GL_POLYGON_OFFSET_BIAS" },
+   { 0x8039, "GL_POLYGON_OFFSET_BIAS_EXT" },
    { 0x803A, "GL_RESCALE_NORMAL" },
    { 0x803B, "GL_ALPHA4" },
    { 0x803C, "GL_ALPHA8" },
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 21646cc..38fa9fa 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -3034,13 +3034,15 @@ teximage(struct gl_context *ctx, GLboolean compressed, GLuint dims,
                                           border, internalFormat, texFormat);
 
                /* Give the texture to the driver.  <pixels> may be null. */
-               if (compressed) {
-                  ctx->Driver.CompressedTexImage(ctx, dims, texImage,
-                                                 imageSize, pixels);
-               }
-               else {
-                  ctx->Driver.TexImage(ctx, dims, texImage, format,
-                                       type, pixels, unpack);
+               if (width > 0 && height > 0 && depth > 0) {
+                  if (compressed) {
+                     ctx->Driver.CompressedTexImage(ctx, dims, texImage,
+                                                    imageSize, pixels);
+                  }
+                  else {
+                     ctx->Driver.TexImage(ctx, dims, texImage, format,
+                                          type, pixels, unpack);
+                  }
                }
 
                check_gen_mipmap(ctx, target, texObj, level);
@@ -3596,10 +3598,10 @@ compressed_subtexture_error_check(struct gl_context *ctx, GLint dimensions,
    if (!_mesa_is_compressed_format(ctx, format))
       return GL_INVALID_ENUM;
 
-   if (width < 1 || width > maxTextureSize)
+   if (width < 0 || width > maxTextureSize)
       return GL_INVALID_VALUE;
 
-   if ((height < 1 || height > maxTextureSize)
+   if ((height < 0 || height > maxTextureSize)
        && dimensions > 1)
       return GL_INVALID_VALUE;
 
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index ed3bbc7..b8e2538 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -1130,11 +1130,18 @@ copy_image_data_to_texture(struct st_context *st,
       /* Copy potentially with the blitter:
        */
       GLuint src_level;
-      if (stImage->pt != stObj->pt)
+      if (stImage->pt->last_level == 0)
          src_level = 0;
       else
          src_level = stImage->base.Level;
 
+      assert(src_level <= stImage->pt->last_level);
+      assert(u_minify(stImage->pt->width0, src_level) == stImage->base.Width);
+      assert(stImage->pt->target == PIPE_TEXTURE_1D_ARRAY ||
+             u_minify(stImage->pt->height0, src_level) == stImage->base.Height);
+      assert(stImage->pt->target == PIPE_TEXTURE_2D_ARRAY ||
+             u_minify(stImage->pt->depth0, src_level) == stImage->base.Depth);
+
       st_texture_image_copy(st->pipe,
                             stObj->pt, dstLevel,  /* dest texture, level */
                             stImage->pt, src_level, /* src texture, level */
