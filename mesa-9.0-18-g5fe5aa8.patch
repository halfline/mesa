diff --git a/bin/get-pick-list.sh b/bin/get-pick-list.sh
new file mode 100755
index 0000000..7288090
--- /dev/null
+++ b/bin/get-pick-list.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+# Script for generating a list of candidates for cherry-picking to a stable branch
+
+# Grep for commits with "cherry picked from commit" in the commit message.
+git log --reverse --grep="cherry picked from commit" origin/master..HEAD |\
+	grep "cherry picked from commit" |\
+	sed -e 's/^[[:space:]]*(cherry picked from commit[[:space:]]*//' -e 's/)//' > already_picked
+
+# Grep for commits that were marked as a candidate for the stable tree.
+git log --reverse --pretty=%H -i --grep='^[[:space:]]*NOTE: This is a candidate' HEAD..origin/master |\
+while read sha
+do
+	# Check to see whether the patch is on the ignore list.
+	if [ -f .git/cherry-ignore ] ; then
+		if grep -q ^$sha .git/cherry-ignore ; then
+			continue
+		fi
+	fi
+
+	# Check to see if it has already been picked over.
+	if grep -q ^$sha already_picked ; then
+		continue
+	fi
+
+	git log -n1 --pretty=oneline $sha | cat
+done
+
+rm -f already_picked
diff --git a/docs/news.html b/docs/news.html
index 541bde6..26e648b 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -9,6 +9,16 @@
 
 <h1>News</h1>
 
+<h2>October 8, 2012</h2>
+
+<p>
+<a href="relnotes-9.0.html">Mesa 9.0</a> is released.
+This is the first version of Mesa to support OpenGL 3.1 and GLSL 1.40
+(with the i965 driver).
+See the release notes for more information about the release.
+</p>
+
+
 <h2>July 10, 2012</h2>
 
 <p>
diff --git a/docs/relnotes-9.0.html b/docs/relnotes-9.0.html
index d72c5bb..02b7324 100644
--- a/docs/relnotes-9.0.html
+++ b/docs/relnotes-9.0.html
@@ -26,7 +26,9 @@ because GL_ARB_compatibility is not supported.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+be4cd34c6599a7cb9d254b05c48bdb1f  MesaLib-9.0.tar.gz
+60e557ce407be3732711da484ab3db6c  MesaLib-9.0.tar.bz2
+16b128544cd3f7e237927bb9f8aab7ce  MesaLib-9.0.zip
 </pre>
 
 
diff --git a/src/gallium/drivers/nv30/nv30_miptree.c b/src/gallium/drivers/nv30/nv30_miptree.c
index 7e67729..18e40e1 100644
--- a/src/gallium/drivers/nv30/nv30_miptree.c
+++ b/src/gallium/drivers/nv30/nv30_miptree.c
@@ -56,8 +56,7 @@ nv30_miptree_get_handle(struct pipe_screen *pscreen,
    if (!mt || !mt->base.bo)
       return FALSE;
 
-   stride = util_format_get_stride(mt->base.base.format,
-                                   mt->base.base.width0);
+   stride = mt->level[0].pitch;
 
    return nouveau_screen_bo_get_handle(pscreen, mt->base.bo, stride, handle);
 }
diff --git a/src/gallium/drivers/nv50/nv50_miptree.c b/src/gallium/drivers/nv50/nv50_miptree.c
index 7b8dfb8..70e8c77 100644
--- a/src/gallium/drivers/nv50/nv50_miptree.c
+++ b/src/gallium/drivers/nv50/nv50_miptree.c
@@ -133,8 +133,7 @@ nv50_miptree_get_handle(struct pipe_screen *pscreen,
    if (!mt || !mt->base.bo)
       return FALSE;
 
-   stride = util_format_get_stride(mt->base.base.format,
-                                   mt->base.base.width0);
+   stride = mt->level[0].pitch;
 
    return nouveau_screen_bo_get_handle(pscreen,
                                        mt->base.bo,
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 751a18f..f83a7a7 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -2981,7 +2981,6 @@
     <enum name="POLYGON_OFFSET_FACTOR"         count="1"  value="0x8038">
         <size name="Get" mode="get"/>
     </enum>
-    <enum name="POLYGON_OFFSET_BIAS"                      value="0x8039"/>
     <enum name="ALPHA4"                                   value="0x803B"/>
     <enum name="ALPHA8"                                   value="0x803C"/>
     <enum name="ALPHA12"                                  value="0x803D"/>
@@ -8089,6 +8088,8 @@
 </category>
 
 <category name="GL_EXT_polygon_offset" number="3">
+    <enum name="POLYGON_OFFSET_BIAS_EXT"                  value="0x8039"/>
+
     <function name="PolygonOffsetEXT" offset="assign">
         <param name="factor" type="GLfloat"/>
         <param name="bias" type="GLfloat"/>
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 6dfa08e..4799af2 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -413,8 +413,10 @@ static void emit_depthbuffer(struct brw_context *brw)
        * tile_x and tile_y to 0.  This is a temporary workaround until we come
        * up with a better solution.
        */
-      tile_x &= ~7;
-      tile_y &= ~7;
+      if (intel->gen >= 6) {
+         tile_x &= ~7;
+         tile_y &= ~7;
+      }
 
       BEGIN_BATCH(len);
       OUT_BATCH(_3DSTATE_DEPTH_BUFFER << 16 | (len - 2));
diff --git a/src/mesa/drivers/dri/intel/intel_screen.c b/src/mesa/drivers/dri/intel/intel_screen.c
index f96583c..00a1b01 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.c
+++ b/src/mesa/drivers/dri/intel/intel_screen.c
@@ -26,6 +26,7 @@
  **************************************************************************/
 
 #include <errno.h>
+#include <time.h>
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index c0e6bc7..a21ae10 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -404,9 +404,6 @@ one_time_init( struct gl_context *ctx )
 
       _mesa_get_cpu_features();
 
-      /* context dependence is never a one-time thing... */
-      _mesa_init_get_hash(ctx);
-
       for (i = 0; i < 256; i++) {
          _mesa_ubyte_to_float_color_tab[i] = (float) i / 255.0F;
       }
@@ -425,6 +422,8 @@ one_time_init( struct gl_context *ctx )
 
    /* per-API one-time init */
    if (!(api_init_mask & (1 << ctx->API))) {
+      _mesa_init_get_hash(ctx);
+
       /*
        * This is fine as ES does not use the remap table, but it may not be
        * future-proof.  We cannot always initialize the remap table because
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index fe1035b..e2ccc29 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -538,6 +538,11 @@ static const struct value_desc values[] = {
    /* GL_{APPLE,ARB,OES}_vertex_array_object */
    { GL_VERTEX_ARRAY_BINDING_APPLE, ARRAY_INT(Name), NO_EXTRA },
 
+   /* GL_EXT_texture_filter_anisotropic */
+   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
+     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
+     extra_EXT_texture_filter_anisotropic },
+
 #if FEATURE_GL || FEATURE_ES1
    /* Enums in OpenGL and GLES1 */
    { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES_BIT | API_OPENGL_CORE_BIT, NO_EXTRA },
@@ -687,11 +692,6 @@ static const struct value_desc values[] = {
    /* GL_EXT_texture_lod_bias */
    { GL_MAX_TEXTURE_LOD_BIAS_EXT, CONTEXT_FLOAT(Const.MaxTextureLodBias),
      NO_EXTRA },
-
-   /* GL_EXT_texture_filter_anisotropic */
-   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
-     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
-     extra_EXT_texture_filter_anisotropic },
 #endif /* FEATURE_GL || FEATURE_ES1 */
 
 #if FEATURE_ES1
@@ -791,6 +791,15 @@ static const struct value_desc values[] = {
 
 #endif /* FEATURE_GL || FEATURE_ES2 */
 
+#if FEATURE_ES1 || FEATURE_ES2
+   { 0, 0, TYPE_API_MASK, API_OPENGLES | API_OPENGLES2_BIT, NO_EXTRA },
+   /* GL_OES_EGL_image_external */
+   { GL_TEXTURE_BINDING_EXTERNAL_OES, LOC_CUSTOM,
+     TYPE_INT, TEXTURE_EXTERNAL_INDEX, extra_OES_EGL_image_external },
+   { GL_TEXTURE_EXTERNAL_OES, LOC_CUSTOM,
+     TYPE_BOOLEAN, 0, extra_OES_EGL_image_external },
+#endif
+
 #if FEATURE_ES2
    /* Enums unique to OpenGL ES 2.0 */
    { 0, 0, TYPE_API_MASK, API_OPENGLES2_BIT, NO_EXTRA },
@@ -803,12 +812,6 @@ static const struct value_desc values[] = {
    { GL_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
 #endif /* FEATURE_ES2 */
 
-   /* GL_OES_EGL_image_external */
-   { GL_TEXTURE_BINDING_EXTERNAL_OES, LOC_CUSTOM,
-     TYPE_INT, TEXTURE_EXTERNAL_INDEX, extra_OES_EGL_image_external },
-   { GL_TEXTURE_EXTERNAL_OES, LOC_CUSTOM,
-     TYPE_BOOLEAN, 0, extra_OES_EGL_image_external },
-
 #if FEATURE_GL
    /* Remaining enums are only in OpenGL */
    { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGL_CORE_BIT, NO_EXTRA },
@@ -1384,45 +1387,54 @@ static const struct value_desc values[] = {
  * collisions for any enum (typical numbers).  And the code is very
  * simple, even though it feels a little magic. */
 
-static unsigned short table[1024];
+static unsigned short table[API_LAST + 1][1024];
 static const int prime_factor = 89, prime_step = 281;
 
 #ifdef GET_DEBUG
 static void
-print_table_stats(void)
+print_table_stats(int api)
 {
    int i, j, collisions[11], count, hash, mask;
    const struct value_desc *d;
-
+   const char *api_names[] = {
+      [API_OPENGL] = "GL",
+      [API_OPENGL_CORE] = "GL_CORE",
+      [API_OPENGLES] = "GLES",
+      [API_OPENGLES2] = "GLES2",
+   };
+   const char *api_name;
+
+   api_name = api < Elements(api_names) ? api_names[api] : "N/A";
    count = 0;
-   mask = Elements(table) - 1;
+   mask = Elements(table[api]) - 1;
    memset(collisions, 0, sizeof collisions);
 
-   for (i = 0; i < Elements(table); i++) {
-      if (!table[i])
-	 continue;
+   for (i = 0; i < Elements(table[api]); i++) {
+      if (!table[api][i])
+         continue;
       count++;
-      d = &values[table[i]];
+      d = &values[table[api][i]];
       hash = (d->pname * prime_factor);
       j = 0;
       while (1) {
-	 if (values[table[hash & mask]].pname == d->pname)
-	    break;
-	 hash += prime_step;
-	 j++;
+         if (values[table[api][hash & mask]].pname == d->pname)
+            break;
+         hash += prime_step;
+         j++;
       }
 
       if (j < 10)
-	 collisions[j]++;
+         collisions[j]++;
       else
-	 collisions[10]++;
+         collisions[10]++;
    }
 
-   printf("number of enums: %d (total %d)\n", count, Elements(values));
+   printf("number of enums for %s: %d (total %ld)\n",
+         api_name, count, Elements(values));
    for (i = 0; i < Elements(collisions) - 1; i++)
       if (collisions[i] > 0)
-	 printf("  %d enums with %d %scollisions\n",
-		collisions[i], i, i == 10 ? "or more " : "");
+         printf("  %d enums with %d %scollisions\n",
+               collisions[i], i, i == 10 ? "or more " : "");
 }
 #endif
 
@@ -1437,27 +1449,30 @@ print_table_stats(void)
 void _mesa_init_get_hash(struct gl_context *ctx)
 {
    int i, hash, index, mask;
+   int api;
    int api_mask = 0, api_bit;
 
-   mask = Elements(table) - 1;
-   api_bit = 1 << ctx->API;
+   api = ctx->API;
+
+   mask = Elements(table[api]) - 1;
+   api_bit = 1 << api;
 
    for (i = 0; i < Elements(values); i++) {
       if (values[i].type == TYPE_API_MASK) {
-	 api_mask = values[i].offset;
-	 continue;
+         api_mask = values[i].offset;
+         continue;
       }
       if (!(api_mask & api_bit))
-	 continue;
+         continue;
 
       hash = (values[i].pname * prime_factor) & mask;
       while (1) {
-	 index = hash & mask;
-	 if (!table[index]) {
-	    table[index] = i;
-	    break;
-	 }
-	 hash += prime_step;
+         index = hash & mask;
+         if (!table[api][index]) {
+            table[api][index] = i;
+            break;
+         }
+         hash += prime_step;
       }
    }
 
@@ -1985,22 +2000,24 @@ find_value(const char *func, GLenum pname, void **p, union value *v)
    struct gl_texture_unit *unit;
    int mask, hash;
    const struct value_desc *d;
+   int api;
 
-   mask = Elements(table) - 1;
+   api = ctx->API;
+   mask = Elements(table[api]) - 1;
    hash = (pname * prime_factor);
    while (1) {
-      d = &values[table[hash & mask]];
+      d = &values[table[api][hash & mask]];
 
       /* If the enum isn't valid, the hash walk ends with index 0,
        * which is the API mask entry at the beginning of values[]. */
       if (unlikely(d->type == TYPE_API_MASK)) {
-	 _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
-                     _mesa_lookup_enum_by_nr(pname));
-	 return &error_value;
+         _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
+               _mesa_lookup_enum_by_nr(pname));
+         return &error_value;
       }
 
       if (likely(d->pname == pname))
-	 break;
+         break;
 
       hash += prime_step;
    }
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index ba43e57..f185ffd 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3340,6 +3340,8 @@ typedef enum
    API_OPENGLES,
    API_OPENGLES2,
    API_OPENGL_CORE,
+
+   API_LAST = API_OPENGL_CORE,
 } gl_api;
 
 /**
diff --git a/src/mesa/main/tests/enum_strings.cpp b/src/mesa/main/tests/enum_strings.cpp
index 7d46080..f4f424d 100644
--- a/src/mesa/main/tests/enum_strings.cpp
+++ b/src/mesa/main/tests/enum_strings.cpp
@@ -563,7 +563,7 @@ const struct enum_info everything[] = {
    { 0x8036, "GL_UNSIGNED_INT_10_10_10_2" },
    { 0x8037, "GL_POLYGON_OFFSET_FILL" },
    { 0x8038, "GL_POLYGON_OFFSET_FACTOR" },
-   { 0x8039, "GL_POLYGON_OFFSET_BIAS" },
+   { 0x8039, "GL_POLYGON_OFFSET_BIAS_EXT" },
    { 0x803A, "GL_RESCALE_NORMAL" },
    { 0x803B, "GL_ALPHA4" },
    { 0x803C, "GL_ALPHA8" },
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 21646cc..38fa9fa 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -3034,13 +3034,15 @@ teximage(struct gl_context *ctx, GLboolean compressed, GLuint dims,
                                           border, internalFormat, texFormat);
 
                /* Give the texture to the driver.  <pixels> may be null. */
-               if (compressed) {
-                  ctx->Driver.CompressedTexImage(ctx, dims, texImage,
-                                                 imageSize, pixels);
-               }
-               else {
-                  ctx->Driver.TexImage(ctx, dims, texImage, format,
-                                       type, pixels, unpack);
+               if (width > 0 && height > 0 && depth > 0) {
+                  if (compressed) {
+                     ctx->Driver.CompressedTexImage(ctx, dims, texImage,
+                                                    imageSize, pixels);
+                  }
+                  else {
+                     ctx->Driver.TexImage(ctx, dims, texImage, format,
+                                          type, pixels, unpack);
+                  }
                }
 
                check_gen_mipmap(ctx, target, texObj, level);
@@ -3596,10 +3598,10 @@ compressed_subtexture_error_check(struct gl_context *ctx, GLint dimensions,
    if (!_mesa_is_compressed_format(ctx, format))
       return GL_INVALID_ENUM;
 
-   if (width < 1 || width > maxTextureSize)
+   if (width < 0 || width > maxTextureSize)
       return GL_INVALID_VALUE;
 
-   if ((height < 1 || height > maxTextureSize)
+   if ((height < 0 || height > maxTextureSize)
        && dimensions > 1)
       return GL_INVALID_VALUE;
 
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index ed3bbc7..b8e2538 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -1130,11 +1130,18 @@ copy_image_data_to_texture(struct st_context *st,
       /* Copy potentially with the blitter:
        */
       GLuint src_level;
-      if (stImage->pt != stObj->pt)
+      if (stImage->pt->last_level == 0)
          src_level = 0;
       else
          src_level = stImage->base.Level;
 
+      assert(src_level <= stImage->pt->last_level);
+      assert(u_minify(stImage->pt->width0, src_level) == stImage->base.Width);
+      assert(stImage->pt->target == PIPE_TEXTURE_1D_ARRAY ||
+             u_minify(stImage->pt->height0, src_level) == stImage->base.Height);
+      assert(stImage->pt->target == PIPE_TEXTURE_2D_ARRAY ||
+             u_minify(stImage->pt->depth0, src_level) == stImage->base.Depth);
+
       st_texture_image_copy(st->pipe,
                             stObj->pt, dstLevel,  /* dest texture, level */
                             stImage->pt, src_level, /* src texture, level */
